---
title: "analysis"
author: "Elen Ghalechyan, Section A"
date: "2024-11-29"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(readxl)
library(dplyr)
library(sf)
library(ggplot2)
library(corrplot)
library(lubridate)
library(systemfonts)
library(GGally)
library(knitr)
library(ggcorrplot)
library(FactoMineR)
library(factoextra)
library(pheatmap)
library(reshape2)
library(spdep)      # For Moran's I and spatial weights
library(spatstat)   # For Ripley's K-function
```

```{r}
data_cleaned <- read.csv("cleaned_water_data.csv")
coordinates <- read.csv("coordinates.csv")

```


```{r}
station_counts <- data_cleaned %>%
  group_by(Water_Object) %>%
  summarise(Number_of_Stations = n())%>%
  arrange(desc(Number_of_Stations))
```
```{r}
top_bottom_counts <- bind_rows(
  head(station_counts, 5), 
  tail(station_counts, 5)  
)

top_bottom_counts
```

```{r}
ggplot(station_counts, aes(x = reorder(Water_Object, -Number_of_Stations), y = Number_of_Stations)) +
  geom_bar(stat = "identity", fill = "steelblue", color = "black", width = 0.7) +
  labs(
    title = "Number of Sampling Stations per Water Object",
    subtitle = "Visualizing the distribution of stations across various water objects",
    x = "Water Object",
    y = "Number of Stations"
  ) +
  theme_classic(base_family = "Arial Unicode MS") +
  theme(
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5, family = "Arial Unicode MS"), 
    plot.subtitle = element_text(size = 12, hjust = 0.5, family = "Arial Unicode MS"),
    axis.text.x = element_text(angle = 90, hjust = 1, family = "Arial Unicode MS"),
  )

```
```{r}
arm_sf <- st_read('Armenia_Marzes.shp', quiet = TRUE) 
```

```{r}
arm_df <- arm_sf %>% group_by(MarzID) %>%
  st_cast("POINT")
arm_df = data.frame(Marz = arm_df$Name_Eng, st_coordinates(arm_df))
```


```{r}
ggplot(arm_df, aes(x = X, y = Y, group = Marz)) +
  geom_polygon(fill = 'white', color = 'black') + coord_fixed()+ theme_void()
```
```{r}
coordinates_data_cleaned <- coordinates %>%
  filter(!is.na(as.numeric(Latitude)) & !is.na(as.numeric(Longitude))) %>%
  mutate(
    Latitude = as.numeric(Latitude),
    Longitude = as.numeric(Longitude)
  )
```



```{r}
# region_counts <- coordinates_data_cleaned %>%
#   group_by(Region) %>%
#   summarise(Number_of_Stations = n())
# 
# arm_sf <- arm_sf %>%
#   left_join(region_counts, by = c("Name_Eng" = "Region"))
# 
# 
# ggplot(data = arm_sf) +
#   geom_sf(aes(fill = Number_of_Stations), color = "black") +
#   scale_fill_gradient(low = "lightblue", high = "darkblue", na.value = "grey") +
#   labs(
#     title = "Regional Distribution of Water Monitoring Stations",
#     fill = "Number of Stations",
#     x = "",
#     y = ""
#   ) +
#   theme_void() +
#   theme(
#     plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
#     legend.position = "right"
#   )
```







Hypothesis 1: There is a spatial correlation between water quality indicators (e.g., BOD5, COD) and the geographic location (X, Y coordinates) of the sampling stations.







**Exploratory Data Analysis (EDA)**

```{r}
# Univariate Analysis - Histogram of Dissolved Oxygen
ggplot(data_cleaned, aes(x = Dissolved_Oxygen)) +
  geom_histogram(binwidth = 1, fill = "blue", color = "black") +
  labs(title = "Distribution of Dissolved Oxygen", x = "Dissolved Oxygen (mg/L)", y = "Frequency")
```


**Outlier Detection**

**Time Series Analysis**


**Correlation Analysis**

```{r}
# Select numeric columns
numeric_cols <- data_cleaned %>%
  select(where(is.numeric))

# Compute correlation matrix
cor_matrix <- cor(numeric_cols, use = "complete.obs")
pairs(numeric_cols[, 1:8], main = "Scatterplot Matrix for Selected Variables")
```

**Principal Component Analysis (PCA)**

```{r}
numeric_data <- data_cleaned %>%
  select(where(is.numeric))
```

```{r}
numeric_data <- numeric_data %>%
  select(where(~ all(!is.na(.)))) 
```

```{r}
numeric_data_scaled <- scale(numeric_data)
```

```{r}
data_pca = prcomp(x = numeric_data_scaled, center = T, scale. = T)
summary(data_pca)
```

```{r}
pheatmap(numeric_data_scaled, cluster_rows = T, cluster_cols = T)
```

```{r}
fviz_screeplot(data_pca, addlabels = T)
```

```{r}
fviz_pca_biplot(data_pca, axes = c(1, 2), geom = c("point", "text"), label = "var")
```


```{r}
fviz_pca_var(data_pca, col.var = "black") 
```

**Clustering**

```{r}
# Use scaled numeric data from the PCA section for clustering
data_for_clustering <- numeric_data_scaled

set.seed(123)  # For reproducibility
fviz_nbclust(data_for_clustering, FUNcluster = factoextra::hcut,
method = "wss")

```

```{r}
fviz_nbclust(data_for_clustering, kmeans, method = "wss") +
labs(title = "K-means Scree Plot")

```
```{r}
# Apply K-means clustering
set.seed(123)
optimal_k <- 3  # Based on the elbow plot
kmeans_result <- kmeans(data_for_clustering, centers = optimal_k, nstart = 25)

# Add cluster labels to the original data
data_cleaned$Cluster <- as.factor(kmeans_result$cluster)

# Create a scatter plot using two selected columns
ggplot(data_cleaned, aes(x = Dissolved_Oxygen, y = BOD5, color = Cluster)) +
  geom_point(size = 3, alpha = 0.7) +
  theme_minimal() +
  labs(
    title = "K-means Clustering Visualization",
    x = "Dissolved Oxygen (mg/L)",
    y = "BOD5 (mg/L)",
    color = "Cluster"
  ) +
  scale_color_brewer(palette = "Set2")

```


```{r}
# Step 3: Hierarchical Clustering
# Compute dissimilarity matrix
dist_matrix <- dist(data_for_clustering, method = "euclidean")

# Perform hierarchical clustering
hclust_result <- hclust(dist_matrix, method = "ward.D2")

# Plot the dendrogram
plot(hclust_result, labels = FALSE, hang = -1,
     main = "Dendrogram of Hierarchical Clustering",
     xlab = "Samples",
     ylab = "Height")

# Cut the dendrogram into clusters
hclust_clusters <- cutree(hclust_result, k = 3)

# Add hierarchical clustering labels to the original data
data_cleaned$HCluster <- as.factor(hclust_clusters)

```



**Geospatial Analysis**


```{r}
# Filter data for "Sevan Lake" and "Debed river basin"
filtered_data <- data_cleaned %>%
  filter(River_Basin %in% c("Sevan Lake", "Debed river basin", "Metsamor river basin"))

# Create a visually appealing boxplot
ggplot(filtered_data, aes(x = River_Basin, y = Dissolved_Oxygen, fill = River_Basin)) +
  geom_boxplot(outlier.color = "red", outlier.size = 2) + # Highlight outliers
  labs(
    title = "Dissolved Oxygen by River Basin",
    subtitle = "Comparing Sevan Lake and Debed River Basin",
    x = "River Basin",
    y = "Dissolved Oxygen (mg/L)"
  ) +
  scale_fill_manual(values = c("Sevan Lake" = "#1f77b4", "Debed river basin" = "#ff7f0e", "Metsamor river basin"='green')) + # Custom colors
  theme(
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
    plot.subtitle = element_text(size = 12, hjust = 0.5),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 14),
    legend.position = "none" # Hide legend as it's clear from labels
  )


```
#Correlation Heatmap

```{r}
# Filter only key numeric columns for correlation analysis
selected_columns <- c("Dissolved_Oxygen", "BOD5", "COD", "NH4", "NO3", "Zn", "Cu", "Pb", "Hardness", "TDS", "Suspended_Solids")
filtered_data <- data[selected_columns]

# Compute the correlation matrix
cor_matrix_filtered <- cor(filtered_data, use = "complete.obs")

# Plot the correlation heatmap
library(ggcorrplot)
ggcorrplot(
  cor_matrix_filtered,
  lab = TRUE, # Show correlation values
  type = "lower", # Show only the lower triangle
  colors = c("blue", "white", "red"), # Color scale
  title = "Clean Correlation Heatmap of Selected Water Quality Parameters",
  outline.color = "black",
  tl.cex = 0.8 # Adjust text size for better readability
)
```
The variables selected for the correlation heatmap are chosen based on their importance in understanding water quality and their interrelation in assessing environmental and ecological conditions. Hereâ€™s an explanation of why these specific variables are included and what they reveal:

Strong Positive Correlations:

BOD5 and COD (0.88): These are both measures of organic pollution, indicating they often increase together in polluted environments.
COD and NH4 (0.77): Indicates that chemical pollution (COD) is often associated with higher ammonium levels, likely due to organic matter decomposition.
TDS and Suspended Solids (0.66): Suggests that higher dissolved solids are often found alongside particulate matter, reflecting general water pollution.
Moderate Correlations:

TDS and Metals (e.g., Zn 0.44): Dissolved solids include metal ions, showing a direct connection between TDS and metal pollution levels.
Weak or Negative Correlations:

DO and NH4 (-0.13): Dissolved oxygen decreases slightly as ammonium levels increase, reflecting oxygen consumption during ammonium nitrification.
DO and BOD5 (-0.32): Dissolved oxygen decreases with higher organic pollution, consistent with oxygen demand from organic matter decomposition.
Key Insights:
Organic and chemical pollution indicators (BOD5, COD, NH4) are closely interrelated, highlighting sources like sewage or industrial discharge.
Suspended solids and TDS are linked to overall water pollution, potentially including heavy metals.
Dissolved oxygen is negatively impacted by pollution, affecting aquatic life.



#Trend analysis for different metals

```{r}
# Trend analysis for different metals
metals <- c("Zn", "Cu", "Cr", "As", "Cd", "Pb")
metal_data <- data_cleaned %>% select(Date, all_of(metals)) %>% melt(id.vars = "Date")

ggplot(metal_data, aes(x = Date, y = value, color = variable)) +
  geom_line() +
  theme_minimal() +
  labs(title = "Trend Analysis of Metal Concentrations Over Time", x = "Date", y = "Concentration") +
  facet_wrap(~variable, scales = "free_y")
  labs(title = "Histogram of Suspended Solids", x = "Suspended Solids", y = "Frequency")
```

```{r}
# Load the shapefile of Armenia
armenia_map <- st_read("Armenia_Marzes.shp")

# Load the coordinates dataset
coordinates <- read.csv("coordinates.csv")

# Step 1: Clean the data
# Convert Longitude and Latitude to numeric, coercing invalid values to NA
coordinates$Longitude <- as.numeric(coordinates$Longitude)
coordinates$Latitude <- as.numeric(coordinates$Latitude)

# Filter out rows with NA in the River_Basin_Area column
coordinates_clean <- coordinates_clean %>%
  filter(!is.na(River_Basin_Area))

# Create an sf object for the monitoring stations
stations_sf <- st_as_sf(coordinates_clean, coords = c("Longitude", "Latitude"), crs = 4326)

# Plot monitoring stations on Armenia's map without NA
ggplot() +
  geom_sf(data = armenia_map, fill = "lightgrey", color = "black") +
  geom_sf(data = stations_sf, aes(color = River_Basin_Area), size = 2) +
  scale_color_viridis_d() +
  labs(title = "Monitoring Stations Across Armenia", color = "River Basin Area") +
  theme_minimal()


```
```{r}
sum(is.na(coordinates$Longitude))
sum(is.na(coordinates$Latitude))
range(coordinates_clean$Longitude)  # Should return a valid numeric range
range(coordinates_clean$Latitude)   # Should return a valid numeric range
# Identify non-numeric Longitude and Latitude entries
non_numeric_long <- coordinates_clean[is.na(as.numeric(coordinates_clean$Longitude)), ]
non_numeric_lat <- coordinates_clean[is.na(as.numeric(coordinates_clean$Latitude)), ]

# Print problematic rows
print(non_numeric_long)
print(non_numeric_lat)
```
